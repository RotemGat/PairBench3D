import bpy
import os
import random
import mathutils
import bmesh

DATA_DIR = "/Users/rotemgatenyo/Desktop/Reichman/Thesis/PairBench3D/data"
OUTPUT_DIR = "/Users/rotemgatenyo/Desktop/Reichman/Thesis/PairBench3D/output"

def clear_scene():
    for obj in list(bpy.data.objects):
        if obj.type == 'MESH':
            bpy.data.objects.remove(obj, do_unlink=True)

def import_obj(filepath):
    existing_objs = set(bpy.data.objects)
    bpy.ops.wm.obj_import(filepath=filepath)
    imported_objs = [obj for obj in bpy.data.objects if obj not in existing_objs and obj.type == 'MESH']
    for obj in bpy.data.objects:
        obj.select_set(False)
    for obj in imported_objs:
        obj.select_set(True)
        bpy.context.view_layer.objects.active = obj
    bpy.ops.object.join()
    return bpy.context.view_layer.objects.active


def move_mesh_geometry_to_origin(obj):
    bpy.context.view_layer.objects.active = obj
    bpy.ops.object.mode_set(mode='EDIT')

    bm = bmesh.from_edit_mesh(obj.data)
    verts = [v.co.copy() for v in bm.verts]
    if not verts:
        bpy.ops.object.mode_set(mode='OBJECT')
        return

    centroid = sum(verts, mathutils.Vector()) / len(verts)

    for v in bm.verts:
        v.co -= centroid

    bmesh.update_edit_mesh(obj.data)
    bpy.ops.object.mode_set(mode='OBJECT')

    print(f"[üéØ] Shifted {obj.name} mesh geometry so centroid is at origin (was {centroid})")
    
def move_centroid_to_origin_and_shift_others(fixed, others):
    move_mesh_geometry_to_origin(fixed)
    # Apply same shift to other meshes so relative positions stay the same
    # (we take centroid from fixed again for consistency)
    centroid = sum((v.co for v in fixed.data.vertices), mathutils.Vector()) / len(fixed.data.vertices)
    for obj in others:
        obj.location -= centroid


def scale_fixed_to_unit_and_match_dynamic(fixed, dynamic):
    bb = [fixed.matrix_world @ mathutils.Vector(corner) for corner in fixed.bound_box]
    diag = (max(bb) - min(bb)).length
    scale = 1.0 / diag
    fixed.scale *= scale
    dynamic.scale *= scale
    for obj in [fixed, dynamic]:
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.transform_apply(location=False, rotation=False, scale=True)

def random_translate(obj, t_range=1.5):
    obj.location = (
        random.uniform(-t_range, t_range),
        random.uniform(0, t_range),
        random.uniform(-t_range, t_range)
    )

def set_origin_to_centroid(obj):
    bpy.context.view_layer.objects.active = obj
    bpy.ops.object.origin_set(type='ORIGIN_CENTER_OF_MASS', center='BOUNDS')

def add_shrinkwrap_constraint(dynamic, fixed):
    c = dynamic.constraints.new('SHRINKWRAP')
    c.name = "AutoAlign"
    c.target = fixed

def nudge_toward_fixed(dynamic, fixed, step_size=0.2):
    direction = (fixed.location - dynamic.location).normalized()
    dynamic.location += direction * step_size

def apply_modifiers_and_unhide(*objs):
    for obj in objs:
        obj.hide_viewport = False
        obj.hide_render = False
        bpy.context.view_layer.objects.active = obj
        for mod in obj.modifiers:
            try:
                bpy.ops.object.modifier_apply(modifier=mod.name)
            except Exception as e:
                print(f"[‚ö†Ô∏è] Failed to apply {mod.name} on {obj.name}: {e}")

def export_meshes(fixed, dynamic, pair_path, suffix=""):
    sample_name = os.path.basename(pair_path)
    out_dir = os.path.join(OUTPUT_DIR, sample_name)
    os.makedirs(out_dir, exist_ok=True)
    for obj in bpy.data.objects:
        obj.select_set(False)
    fixed.select_set(True)
    dynamic.select_set(True)
    bpy.context.view_layer.objects.active = dynamic
    out_path = os.path.join(out_dir, f"{sample_name}{suffix}.obj")
    bpy.ops.wm.obj_export(
        filepath=out_path,
        export_selected_objects=True,
        export_materials=True,
        export_normals=True,
        export_uv=True,
        export_triangulated_mesh=True,
        path_mode='COPY'
    )
    print(f"[üíæ] Exported to {out_path}")

def render_to_file(pair_path):
    sample_name = os.path.basename(pair_path)
    out_dir = os.path.join(OUTPUT_DIR, sample_name)
    os.makedirs(out_dir, exist_ok=True)

    scene = bpy.context.scene

    # Use EEVEE instead of Cycles
    scene.render.engine = 'BLENDER_EEVEE_NEXT'

    # Ensure camera exists and set focal length = 60
    if scene.camera and scene.camera.type == 'CAMERA':
        scene.camera.data.lens = 60
        print(f"[üì∑] Using camera '{scene.camera.name}' at {scene.camera.location}, lens = 60mm")
    else:
        print("[‚ö†Ô∏è] No active camera found, rendering may fail!")

    # Render settings
    scene.render.image_settings.file_format = 'PNG'
    scene.render.resolution_x = 512
    scene.render.resolution_y = 512
    scene.render.filepath = os.path.join(out_dir, f"{sample_name}.png")

    bpy.ops.render.render(write_still=True)
    print(f"[üì∏] Rendered to {scene.render.filepath}")


def process_mesh_pair(pair_path):
    folders = [d for d in os.listdir(pair_path) if os.path.isdir(os.path.join(pair_path, d))]
    if len(folders) != 2:
        print(f"[‚ö†Ô∏è] Skipping {pair_path}")
        return
    name_a, name_b = folders
    obj_a = os.path.join(pair_path, name_a, next(f for f in os.listdir(os.path.join(pair_path, name_a)) if f.endswith(".obj")))
    obj_b = os.path.join(pair_path, name_b, next(f for f in os.listdir(os.path.join(pair_path, name_b)) if f.endswith(".obj")))
    if random.random() < 0.5:
        fixed_path, dynamic_path = obj_a, obj_b
    else:
        fixed_path, dynamic_path = obj_b, obj_a
    clear_scene()
    fixed = import_obj(fixed_path)
    dynamic = import_obj(dynamic_path)
    fixed.name = "FixedMesh"
    dynamic.name = "DynamicMesh"
    move_centroid_to_origin_and_shift_others(fixed, [dynamic])
    scale_fixed_to_unit_and_match_dynamic(fixed, dynamic)
    random_translate(dynamic)
    set_origin_to_centroid(dynamic)
    export_meshes(fixed, dynamic, pair_path, suffix="__init")
    add_shrinkwrap_constraint(dynamic, fixed)
    for _ in range(5):
        nudge_toward_fixed(dynamic, fixed, 0.1)
    apply_modifiers_and_unhide(fixed, dynamic)
    export_meshes(fixed, dynamic, pair_path)
    render_to_file(pair_path)

def main():
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    for folder in os.listdir(DATA_DIR):
        path = os.path.join(DATA_DIR, folder)
        if os.path.isdir(path):
            process_mesh_pair(path)

if __name__ == "__main__":
    main()
